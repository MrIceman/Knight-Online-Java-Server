package com.knightonline.shared.network.common;

import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * @author Mamaorha
 *
 */
public abstract class PacketHandler implements Runnable
{
	private static final String PACKET_HANDLER_THREAD = "packet handler thread";

	protected Map<Short, IPacketHandler> packetTypesHandlers;
	protected BlockingQueue<Packet> requestQueue;
	protected ExecutorService threadExecutors;
	protected AtomicBoolean isAlive;

	public PacketHandler()
	{
		this.packetTypesHandlers = new ConcurrentHashMap<>();
		this.requestQueue = new LinkedBlockingQueue<Packet>();

		this.isAlive = new AtomicBoolean(true);
		this.threadExecutors = Executors.newFixedThreadPool(getNumberOfThreads());
		this.threadExecutors.submit(this);
	}

	protected abstract void initializePacketTypesHandlers();
	protected abstract int getNumberOfThreads();

	@Override
	public void run()
	{
		Thread.currentThread().setName(PACKET_HANDLER_THREAD);
	
		try
		{
			while (isAlive.get())
			{
				Packet requestPacket = requestQueue.take();
				
				IPacketHandler handler = packetTypesHandlers.get(requestPacket.getOpcode());
				
				if(null != handler)
				{
					handler.handlePacket(requestPacket);
				}
			}
		}
		
		catch (Exception e)
		{
			if (isAlive.get())
			{
				e.printStackTrace();
			}
		}

	}

	public void addWork(Packet packet) throws InterruptedException
	{
		requestQueue.put(packet);
	}
}
