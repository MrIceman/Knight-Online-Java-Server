package com.knightonline.shared.network;

import java.io.Serializable;
import java.net.InetSocketAddress;
import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;

import org.jboss.netty.bootstrap.ServerBootstrap;
import org.jboss.netty.channel.Channel;
import org.jboss.netty.channel.ChannelFuture;
import org.jboss.netty.channel.ChannelHandlerContext;
import org.jboss.netty.channel.ChannelPipeline;
import org.jboss.netty.channel.socket.nio.NioServerSocketChannelFactory;
import org.springframework.beans.factory.annotation.Autowired;

import com.knightonline.shared.exception.ConnectivityException;
import com.knightonline.shared.network.common.IConnectionStateReport;
import com.knightonline.shared.network.common.IResponseHandler;
import com.knightonline.shared.network.common.MessageInfo;
import com.knightonline.shared.network.common.ServerConfiguration;
import com.knightonline.shared.network.packet.PacketHandler;
import com.knightonline.shared.network.pipelinefactory.PipelineFactory;
import com.knightonline.shared.network.pipelinefactory.PipelineFactoryBuilder;

/**
 * @author Mamaorha
 *
 */
public class Server implements IConnectionStateReport, Runnable, IResponseHandler
{
	@Autowired
	protected PacketHandler packetHandler;
	
	//input
	protected ServerConfiguration configuration;
	
	//variables
	protected BlockingQueue<MessageInfo> requestQueue;
	protected AtomicLong channelIdSeq;
	protected Map<Long, ChannelPipeline> channelPipelineMap;
	protected Channel serverChannel;
	protected ServerBootstrap bootstrap;
	protected ExecutorService threadExecutors;
	protected AtomicBoolean isAlive;

	public Server(ServerConfiguration configuration)
	{
		init(configuration);
	}

	private void init(ServerConfiguration configuration) throws ConnectivityException
	{
		this.configuration = configuration;
		this.requestQueue = new LinkedBlockingQueue<MessageInfo>();
		this.bootstrap = new ServerBootstrap(new NioServerSocketChannelFactory(Executors.newCachedThreadPool(), Executors.newCachedThreadPool()));
		this.channelIdSeq = new AtomicLong(0);
		this.channelPipelineMap = new ConcurrentHashMap<Long, ChannelPipeline>();

		// Set up the pipeline factory.
		this.bootstrap.setOption("child.tcpNoDelay", true);
		this.bootstrap.setOption("child.receiveBufferSize", configuration.getReceiveBufferSize());

		System.out.println(String.format("server configuration handler type [%s]", configuration.getHandlerType().toString()));

		PipelineFactory channelPipelineFactory = PipelineFactoryBuilder.buildChannelPipelineFactory(configuration.getHandlerType());

		System.out.println(String.format("Created pipeline factory [%s] successfully", channelPipelineFactory.getClass().getName()));

		channelPipelineFactory.init(this, requestQueue, channelIdSeq);

		bootstrap.setPipelineFactory(channelPipelineFactory);

		// Bind and start to accept incoming connections.
		this.serverChannel = bootstrap.bind(new InetSocketAddress(configuration.getIp(), configuration.getPort()));

		System.out.println(String.format("Server listen on [%s:%s]", configuration.getIp(), configuration.getPort()));

		this.isAlive = new AtomicBoolean(true);
		this.threadExecutors = Executors.newFixedThreadPool(1);
		this.threadExecutors.submit(this);
	}
	
	public void shutdown()
	{
		this.serverChannel.disconnect();
		this.serverChannel.close();
		this.bootstrap.releaseExternalResources();
	}

	@Override
	public void connected(long channelId, ChannelHandlerContext ctx)
	{
		if (!channelPipelineMap.containsKey(channelId))
		{
			channelPipelineMap.put(channelId, ctx.getPipeline());
			System.out.println(String.format("client connected [%s]", channelId));
		}
	}

	@Override
	public void disconnected(long channelId, ChannelHandlerContext ctx)
	{
		ChannelPipeline channelPipeline = channelPipelineMap.get(channelId);

		if (channelPipeline != null)
		{
			channelPipelineMap.remove(channelId);
			System.out.println(String.format("client disconnected [%s]", channelId));
		}
	}

	@Override
	public void run()
	{
		Thread.currentThread().setName("Reviever - Sender Thread");

		try
		{
			while (isAlive.get())
			{
				MessageInfo messageInfo = requestQueue.take();
				packetHandler.addWork(messageInfo);
			}
		}
		catch (Exception e)
		{
			if (isAlive.get())
			{
				e.printStackTrace();
			}
		}
	}
	
	@Override
	public void sendAsyncResponseMessage(MessageInfo messageInfo) throws ConnectivityException
	{
		sendResponseMessage(messageInfo, false);
	}

	private void sendResponseMessage(MessageInfo messageInfo, boolean sync) throws ConnectivityException
	{
		Serializable response = messageInfo.getResponse();

		if (response == null)
		{
			throw new ConnectivityException("Response Object is empty");
		}

		ChannelPipeline channelPipeline = channelPipelineMap.get(messageInfo.getChannelId());

		Serializable message = messageInfo.getResponse();

		if (channelPipeline != null)
		{
			if (channelPipeline.getChannel().isConnected())
			{
				ChannelFuture channelFuture = channelPipeline.getChannel().write(message);

				if (sync)
				{
					boolean isCompleted = channelFuture.awaitUninterruptibly(this.configuration.getMsgTimeout(), TimeUnit.MILLISECONDS);

					if (!isCompleted)
					{
						throw new ConnectivityException(String.format("Got timeout for response to be completed within the specified time limit [%s] milliseconds ", this.configuration.getMsgTimeout()));
					}
				}
			}
			
			else
			{
				channelPipelineMap.remove(messageInfo.getChannelId());
				throw new ConnectivityException(String.format("Channel Id [%s] is disconnected and removed from channels map", messageInfo.getChannelId()));
			}
		}
		
		else
		{
			throw new ConnectivityException(String.format("Channel Id [%s] is not defined in channel map", messageInfo.getChannelId()));
		}
	}
}
